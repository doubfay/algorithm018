# 学习笔记

## 学习内容

* 高级动态规划
* 字符串算法
  * 基础
  * 高级
  * 匹配算法

### 高级动态规划

#### 动态规划复习

思想：分治 + 最优子结构（中途可以淘汰次优解）

步骤：
* 寻找最近重复子问题
* 定义 DP 状态数组
* 定义 DP 递推方程

#### 高级动态规划

在：定义 DP 状态数组、定义 DP 递推方程，更加复杂

如果一维状态数组无法解决，可以尝试增加维度

和字符串结合时，例如两个字符串匹配，定义二维的状态数组 `DP[i][j]`，i 表示第一个字符串的 0~i 位，j 表示第二个字符串的 0~j 位；



### 字符串算法

#### 基础

Java 中字符串是「不可变的」

字符串 == 比较的是引用，即内存地址；
字符串 `equals` 比较的是值；

* 基础操作
* 回文
* 异位词

#### 高级

字符串 + DP / 递归

#### 匹配算法

* 暴力
* Rabin-Karp 算法
* KMP 算法

其中 Rabin-Karp 算法和 KMP 算法，都是基于暴力的匹配算法，做了优化

##### Rabin-Karp 算法

* 匹配字符串 pattern，长度 M，计算出其 Hash 值 hash_pattern
* 目标字符串 target，长度 N

匹配时：
1. 计算 target 长度为 M 的子串的 Hash 值 hash_sub
2. 比较 hash_sub 和 hash_pattern 的值是否相等
   2. 1. 不相等，说明不匹配
   2. 2. 相等，则再使用朴素比较方法，对 target 的子串和 pattern 逐个字符进行比较
3. 如果上述两步，没有找到匹配的串，那么 target 的匹配子串再往后面移动一位

有点类似布隆过滤器

在计算 Hash 值的时候，不能使用系统自带的 Hash 函数，其时间复杂度是 O(M)；

可以自己设计 Hash 函数，将字符串当作是一个 256 进制的数，算出对应的十进制值，再模一个比较大的素数（取余 %，目的是不让计算出的十进制数太大），这样可以在 O(1) 的时间复杂度内求出 Hash 值；

##### KMP 算法

Rabin-Karp 算法在匹配时，还是逐个字符、逐个字符往后移动匹配；

KMP 算法在匹配时，不是只移动一个字符，会根据匹配字符串 pattern 中的前缀、后缀，可能在匹配过程中移动多个字符（避免重复匹配）；
